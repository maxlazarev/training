<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesQuantity_RORReturnNote</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactory(DocumentStatus::RORReturnNote)]
class SalesQuantity_RORReturnNote extends SalesQuantity
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcQtyInvent</Name>
				<Source><![CDATA[
    protected container calcQtyInvent(Common                    _salesLine,
                                      SalesUpdate               _specQty             = SalesUpdate::All,
                                      InventQty                 _qty                 = naReal(),
                                      boolean                   _creditRemaining     = false,
                                      boolean                   _calcRemaining       = true,
                                      PackingSlipIdForUpdate_W  _packingSlips        = "")
    {
        SalesLine   salesLine = _salesLine as SalesLine;
        InventQty   qtyAvailable = this.RORgetSubStatusFromToQty(salesLine, _qty, salesLine.inventTable().inventUnitId());
        InventQty   qtyUpdate;
        InventQty   numOfRemainOrig;
        InventQty   qtyRemainNew;
    
        if (_qty != naReal())
        {
            qtyUpdate = _qty;
        }
        else
        {
            switch (_specQty)
            {
                case SalesUpdate::DeliverNow :
                    qtyUpdate = salesLine.inventDeliverNow;
                    break;
    
                default :
                    qtyUpdate = qtyAvailable;
                    break;
            }
        }
    
        if (_calcRemaining)
        {
            numOfRemainOrig = salesLine.RORRemainInventReturn;
            qtyRemainNew    = salesLine.RORRemainInventReturn - qtyUpdate;
        }
    
        qtyUpdate       = qtyUpdate       == naReal() ? 0 : qtyUpdate;
        numOfRemainOrig = numOfRemainOrig == naReal() ? 0 : numOfRemainOrig;
        qtyRemainNew    = qtyRemainNew    == naReal() ? 0 : qtyRemainNew;
    
        return [qtyUpdate, numOfRemainOrig, qtyRemainNew];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcQtySales</Name>
				<Source><![CDATA[
    protected container calcQtySales(Common                     _salesLine,
                                     SalesUpdate                _specQty             = SalesUpdate::All,
                                     SalesQty                   _qty                 = naReal(),
                                     boolean                    _creditRemaining     = false,
                                     boolean                    _calcRemaining       = true,
                                     PackingSlipIdForUpdate_W   _packingSlips         = "")
    {
        SalesLine   salesLine = _salesLine as SalesLine;
        SalesQty    qtyAvailable = this.RORgetSubStatusFromToQty(salesLine, _qty, salesLine.SalesUnit);
        SalesQty    qtyUpdate;
        SalesQty    numOfRemainOrig;
        SalesQty    qtyRemainNew;
    
        if (_qty != naReal())
        {
            qtyUpdate = min(_qty, qtyAvailable);
        }
        else
        {
            switch (_specQty)
            {
                case SalesUpdate::DeliverNow  :
                    qtyUpdate = salesLine.salesDeliverNow;
                    break;
    
                default :
                    qtyUpdate = qtyAvailable;
                    break;
            }
        }
    
        if (_calcRemaining)
        {
            numOfRemainOrig = salesLine.RORRemainSalesReturn;
            qtyRemainNew   = salesLine.RORRemainSalesReturn - qtyUpdate;
        }
    
        qtyUpdate       = qtyUpdate       == naReal() ? 0 : qtyUpdate;
        numOfRemainOrig = numOfRemainOrig == naReal() ? 0 : numOfRemainOrig;
        qtyRemainNew    = qtyRemainNew    == naReal() ? 0 : qtyRemainNew;
    
        return [qtyUpdate, numOfRemainOrig, qtyRemainNew];
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWCalcQtyInvent</Name>
				<Source><![CDATA[
    protected container pdsCWCalcQtyInvent(
        Common         _common,
        SalesUpdate    _specQty             = SalesUpdate::All,
        PdsCWInventQty _qty                 = naReal(),
        boolean        _creditRemaining     = false,
        boolean        _calcRemaining       = true)
    {
        return [0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyRemainInventPhysical</Name>
				<Source><![CDATA[
    public InventQty qtyRemainInventPhysical(SalesLine _salesLine, SalesParmLine _salesParmLine)
    {
        return _salesParmLine.remainBeforeInvent - _salesParmLine.remainAfterInvent;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>